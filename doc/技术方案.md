# PawzyPop 技术方案

## 1. 架构设计

### 1.1 整体架构

```
┌─────────────────────────────────────────────────────────┐
│                      UI Layer                            │
│  (GameUI, MenuUI, Popups, UIManager)                    │
├─────────────────────────────────────────────────────────┤
│                    Game Logic Layer                      │
│  (GameManager, Board, MatchFinder, MatchProcessor)      │
├─────────────────────────────────────────────────────────┤
│                     Input Layer                          │
│  (InputManager - Mouse/Touch)                           │
├─────────────────────────────────────────────────────────┤
│                     Data Layer                           │
│  (LevelData, SaveManager, TileType)                     │
├─────────────────────────────────────────────────────────┤
│                   Support Systems                        │
│  (AudioManager, ParticleManager, CameraScaler)          │
└─────────────────────────────────────────────────────────┘
```

### 1.2 核心类关系

```
GameManager (游戏流程控制)
    │
    ├── Board (棋盘管理)
    │       │
    │       ├── Tile[] (图块数组)
    │       └── TileType (图块类型)
    │
    ├── MatchFinder (匹配检测)
    │
    ├── MatchProcessor (匹配处理)
    │
    └── InputManager (输入处理)
```

## 2. 核心算法

### 2.1 匹配检测算法

```csharp
// 水平匹配检测
for (int y = 0; y < height; y++) {
    for (int x = 0; x < width - 2; x++) {
        List<Tile> match = GetHorizontalMatch(x, y);
        if (match.Count >= 3) {
            matchedTiles.AddRange(match);
        }
    }
}

// 垂直匹配检测
for (int x = 0; x < width; x++) {
    for (int y = 0; y < height - 2; y++) {
        List<Tile> match = GetVerticalMatch(x, y);
        if (match.Count >= 3) {
            matchedTiles.AddRange(match);
        }
    }
}
```

### 2.2 下落填充算法

```csharp
// 列塌陷算法
for (int x = 0; x < width; x++) {
    int writeY = 0;
    for (int readY = 0; readY < height; readY++) {
        if (!Tiles[x, readY].IsEmpty) {
            if (readY != writeY) {
                // 移动图块到空位
                SwapTiles(x, readY, x, writeY);
            }
            writeY++;
        }
    }
    // 填充顶部空位
    for (int y = writeY; y < height; y++) {
        Tiles[x, y].SetType(GetRandomTileType());
    }
}
```

### 2.3 相机自适应算法

```csharp
float screenAspect = Screen.width / Screen.height;
float targetAspect = requiredWidth / requiredHeight;

if (screenAspect >= targetAspect) {
    // 屏幕较宽，以高度为基准
    orthoSize = requiredHeight / 2f;
} else {
    // 屏幕较窄，以宽度为基准
    orthoSize = requiredWidth / (2f * screenAspect);
}
```

## 3. 数据结构

### 3.1 关卡数据 (LevelData)

```csharp
[System.Serializable]
public class LevelData
{
    public int levelId;
    public int targetScore;
    public int maxMoves;
    public int boardWidth;
    public int boardHeight;
}
```

### 3.2 图块类型 (TileType)

```csharp
[CreateAssetMenu(fileName = "TileType", menuName = "PawzyPop/TileType")]
public class TileType : ScriptableObject
{
    public string typeName;
    public Sprite sprite;
    public Color color;
}
```

### 3.3 存档数据

```csharp
[System.Serializable]
public class SaveData
{
    public int currentLevel;
    public int highScore;
    public int totalStars;
    public Dictionary<int, int> levelStars;
}
```

## 4. 游戏流程

### 4.1 初始化流程

```
1. GameManager.Awake()
   └── 初始化单例

2. Board.Start()
   ├── InitializeBoard()
   │   ├── GenerateBoard() - 生成图块
   │   └── CenterBoard() - 居中棋盘
   └── 添加 CameraScaler

3. MatchFinder.Start()
   └── 获取 Board 引用

4. InputManager.Start()
   └── 获取 Camera 引用
```

### 4.2 游戏循环

```
1. 玩家输入 (滑动)
   └── InputManager.OnSwapRequested

2. 交换图块
   └── MatchProcessor.TrySwap()

3. 检测匹配
   └── MatchFinder.FindMatchesAt()

4. 处理匹配
   ├── 消除匹配图块
   ├── 播放动画/特效
   └── 更新分数

5. 下落填充
   ├── Board.CollapseColumns()
   └── Board.RefillBoard()

6. 连锁检测
   └── 重复步骤 3-5 直到无匹配

7. 检查游戏状态
   ├── 达成目标 → 胜利
   ├── 步数用尽 → 失败
   └── 继续游戏
```

## 5. 屏幕适配方案

### 5.1 问题分析

- 不同设备屏幕比例差异大 (16:9, 18:9, 19.5:9 等)
- 需要确保游戏内容在所有设备上完整显示
- 需要保持游戏内容居中

### 5.2 解决方案

使用 `CameraScaler` 组件：

1. **计算目标区域**: 根据棋盘大小 + 边距计算需要显示的区域
2. **比较宽高比**: 比较屏幕宽高比和目标区域宽高比
3. **调整正交大小**:
   - 屏幕较宽: 以高度为基准
   - 屏幕较窄: 以宽度为基准
4. **动态监听**: 监听屏幕尺寸变化，自动调整

### 5.3 关键代码

```csharp
public void AdjustToBoard(int boardWidth, int boardHeight, 
                          float tileSize, float tileSpacing)
{
    float totalTileSize = tileSize + tileSpacing;
    targetWidth = boardWidth * totalTileSize;
    targetHeight = boardHeight * totalTileSize;
    AdjustCamera();
}
```

## 6. 性能优化

### 6.1 对象池

- 图块使用对象池复用，避免频繁创建销毁
- 粒子特效使用对象池管理

### 6.2 批处理

- 使用 SpriteRenderer 的批处理
- 相同材质的图块自动合批

### 6.3 内存管理

- 使用 ScriptableObject 存储图块类型配置
- 关卡数据按需加载

## 7. 扩展性设计

### 7.1 新增图块类型

1. 在 `Resources/TileTypes/` 创建新的 TileType 资源
2. 在 Board Inspector 中添加到 tileTypes 数组

### 7.2 新增关卡

1. 在 `Resources/Levels/` 创建新的 JSON 文件
2. 配置关卡参数

### 7.3 新增特殊图块

1. 继承 `Tile` 类创建特殊图块
2. 在 `MatchProcessor` 中添加特殊处理逻辑

## 8. 已知问题与解决方案

### 8.1 MatchFinder 空引用 (已修复)

**问题**: `MatchFinder.board` 在 `Board.GenerateBoard()` 调用时未初始化

**解决**: 添加 `EnsureBoardReference()` 方法，在使用前确保引用有效

### 8.2 安卓屏幕适配 (已修复)

**问题**: 游戏内容在安卓设备上显示位置偏移

**解决**: 新增 `CameraScaler` 组件，自动调整相机正交大小
